// Prisma Schema for Smart Business Assistant
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Multi-tenancy: Each business is a tenant
model Tenant {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  email     String   @unique
  phone     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  users        User[]
  customers    Customer[]
  services     Service[]
  appointments Appointment[]
  quotes       Quote[]
  invoices     Invoice[]
  availability TechnicianAvailability[]
  timeOff      TimeOff[]
  callLogs     CallLog[]
  invitations  TeamInvitation[]
  jobs         Job[]
  smsBroadcasts SmsBroadcast[]
  settings     TenantSettings?
  reviewRequests ReviewRequest[]
  quoteFollowUps QuoteFollowUp[]
  paymentReminders PaymentReminder[]
  appointmentReminders AppointmentReminder[]
  waitlistEntries Waitlist[]
  aiUsageLogs     AiUsageLog[]
  aiFeedback      AiFeedback[]
  retentionCampaigns RetentionCampaign[]
  serviceIntervals   ServiceInterval[]
  technicianSkills   TechnicianSkill[]
  messageClassifications MessageClassification[]
  autoResponderRules AutoResponderRule[]
  copilotConversations CopilotConversation[]
  weeklyReports WeeklyReport[]
  agentInsights AgentInsight[]

  @@map("tenants")
}

// Users belong to tenants (staff/admin)
model User {
  id        String     @id @default(cuid())
  email     String     @unique
  password  String?
  name      String
  phone     String?
  role      UserRole   @default(TECHNICIAN)
  status    UserStatus @default(ACTIVE)
  tenantId  String
  clerkId   String?    @unique
  invitedBy String?
  joinedAt  DateTime?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // Relations
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointments Appointment[]
  availability TechnicianAvailability[]
  timeOff      TimeOff[]
  jobs         Job[]
  locations    TechnicianLocation[]
  skills       TechnicianSkill[]

  @@index([tenantId])
  @@index([clerkId])
  @@index([status])
  @@map("users")
}

enum UserRole {
  OWNER      // Business owner, full access
  ADMIN      // Admin access, can manage team
  DISPATCHER // Can manage appointments and customers
  TECHNICIAN // Field worker, limited access
}

enum UserStatus {
  PENDING    // Invited but not yet joined
  ACTIVE     // Active team member
  DEACTIVATED // Removed from team
}

enum SkillLevel {
  BASIC
  INTERMEDIATE
  EXPERT
}

// Team invitations
model TeamInvitation {
  id        String           @id @default(cuid())
  email     String
  name      String?
  role      UserRole         @default(TECHNICIAN)
  tenantId  String
  token     String           @unique
  status    InvitationStatus @default(PENDING)
  expiresAt DateTime
  invitedBy String
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, email])
  @@index([token])
  @@index([tenantId])
  @@map("team_invitations")
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

// Customers are tenant-specific
model Customer {
  id        String   @id @default(cuid())
  name      String
  email     String?
  phone     String
  address   String?
  notes     String?
  tenantId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointments Appointment[]
  quotes       Quote[]
  invoices     Invoice[]
  reviewRequests ReviewRequest[]
  context      CustomerContext?
  preferences  CustomerPreference?
  location     CustomerLocation?
  auth         CustomerAuth?
  equipment    CustomerEquipment[]
  riskProfile  CustomerRiskProfile?
  noShowCount  Int               @default(0)
  healthScore    Int             @default(50)
  churnRisk      Float           @default(0)
  lifecycleStage String          @default("NEW")
  waitlistEntries Waitlist[]
  retentionCampaigns RetentionCampaign[]

  @@index([tenantId])
  @@index([phone])
  @@map("customers")
}

// Services catalog
model Service {
  id              String        @id @default(cuid())
  name            String
  description     String?
  durationMinutes Int           @default(60)
  price           Decimal?  @db.Decimal(10, 2)
  tenantId        String
  // Availability settings
  bufferMinutes   Int           @default(0)      // Buffer time after appointment
  maxPerDay       Int?                            // Max appointments per day (null = unlimited)
  leadTimeHours   Int           @default(24)     // Minimum hours before appointment can be booked
  isActive        Boolean       @default(true)   // Whether service accepts bookings
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointments Appointment[]
  availability ServiceAvailability[]
  waitlistEntries Waitlist[]
  serviceInterval ServiceInterval?
  technicianSkills TechnicianSkill[]

  @@index([tenantId])
  @@map("services")
}

// Service-specific availability windows
model ServiceAvailability {
  id         String   @id @default(cuid())
  serviceId  String
  dayOfWeek  Int      // 0 = Sunday, 6 = Saturday
  startTime  String   // Format: "HH:mm" (e.g., "09:00")
  endTime    String   // Format: "HH:mm" (e.g., "17:00")
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([serviceId, dayOfWeek])
  @@index([serviceId])
  @@map("service_availability")
}

// Appointments for services
model Appointment {
  id                String            @id @default(cuid())
  customerId        String
  serviceId         String?
  assignedTo        String?
  scheduledAt       DateTime
  duration          Int               @default(60)
  status            AppointmentStatus @default(SCHEDULED)
  notes             String?
  tenantId          String
  confirmationCode  String?           @unique
  manageToken       String?           @unique  // Token for customer to manage their booking
  confirmedAt       DateTime?
  cancelledAt       DateTime?
  cancelReason      String?
  googleCalendarEventId String?       // Google Calendar event ID for sync
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // Relations
  tenant       Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer     Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  service      Service? @relation(fields: [serviceId], references: [id], onDelete: SetNull)
  assignedUser User?    @relation(fields: [assignedTo], references: [id], onDelete: SetNull)
  job          Job?
  reminders    AppointmentReminder[]

  @@index([tenantId])
  @@index([customerId])
  @@index([scheduledAt])
  @@index([assignedTo])
  @@index([status])
  @@index([manageToken])
  @@map("appointments")
}

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

model AppointmentReminder {
  id            String   @id @default(cuid())
  tenantId      String
  appointmentId String
  step          Int      // 1=48h email, 2=24h SMS, 3=2h SMS
  channel       String   // SMS, EMAIL
  scheduledAt   DateTime
  sentAt        DateTime?
  status        String   @default("PENDING") // PENDING, SENT, CANCELLED
  createdAt     DateTime @default(now())

  tenant      Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([appointmentId])
  @@index([status, scheduledAt])
  @@map("appointment_reminders")
}

model Waitlist {
  id             String    @id @default(cuid())
  tenantId       String
  customerId     String
  serviceId      String?
  preferredDate  DateTime?
  preferredStart String?   // "HH:mm"
  preferredEnd   String?   // "HH:mm"
  status         String    @default("WAITING") // WAITING, OFFERED, BOOKED, EXPIRED, CANCELLED
  notifiedAt     DateTime?
  expiresAt      DateTime
  notes          String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  service  Service? @relation(fields: [serviceId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([serviceId, status])
  @@map("waitlist")
}

// Quotes/Estimates
model Quote {
  id          String      @id @default(cuid())
  quoteNumber String      @unique
  description String
  amount      Decimal   @db.Decimal(10, 2)
  validUntil  DateTime
  status      QuoteStatus @default(DRAFT)
  customerId  String
  tenantId    String
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  sentAt      DateTime?
  viewedAt    DateTime?
  convertedAt DateTime?

  // Relations
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  items    QuoteItem[]
  followUps QuoteFollowUp[]

  @@index([tenantId])
  @@index([customerId])
  @@map("quotes")
}

enum QuoteStatus {
  DRAFT
  SENT
  ACCEPTED
  REJECTED
  EXPIRED
}

model QuoteItem {
  id          String   @id @default(cuid())
  description String
  quantity    Int
  unitPrice   Decimal  @db.Decimal(10, 2)
  total       Decimal  @db.Decimal(10, 2)
  quoteId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  quote Quote @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  @@index([quoteId])
  @@map("quote_items")
}

model QuoteFollowUp {
  id          String   @id @default(cuid())
  tenantId    String
  quoteId     String
  step        Int
  channel     String   // SMS or EMAIL
  scheduledAt DateTime
  sentAt      DateTime?
  status      String   @default("PENDING") // PENDING, SENT, CANCELLED
  createdAt   DateTime @default(now())

  quote  Quote  @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([quoteId])
  @@index([status, scheduledAt])
  @@map("quote_follow_ups")
}

// Invoices
model Invoice {
  id            String        @id @default(cuid())
  invoiceNumber String        @unique
  description   String
  amount        Decimal       @db.Decimal(10, 2)
  paidAmount    Decimal       @default(0) @db.Decimal(10, 2)
  status        InvoiceStatus @default(DRAFT)
  dueDate       DateTime
  paidAt        DateTime?
  sentAt        DateTime?
  customerId    String
  quoteId       String?
  tenantId      String
  stripePaymentIntentId String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  depositAmount     Decimal?      @db.Decimal(10, 2)
  lateFeeApplied    Boolean       @default(false)
  lateFeeAmount     Decimal?      @db.Decimal(10, 2)

  // Relations
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  items    InvoiceItem[]
  reminders PaymentReminder[]

  @@index([tenantId])
  @@index([customerId])
  @@index([quoteId])
  @@map("invoices")
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
  CANCELLED
}

model InvoiceItem {
  id          String   @id @default(cuid())
  description String
  quantity    Int
  unitPrice   Decimal  @db.Decimal(10, 2)
  total       Decimal  @db.Decimal(10, 2)
  invoiceId   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@map("invoice_items")
}

model PaymentReminder {
  id          String   @id @default(cuid())
  tenantId    String
  invoiceId   String
  step        Int
  channel     String   // SMS, EMAIL, BOTH
  scheduledAt DateTime
  sentAt      DateTime?
  status      String   @default("PENDING") // PENDING, SENT, CANCELLED
  createdAt   DateTime @default(now())

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([invoiceId])
  @@index([status, scheduledAt])
  @@map("payment_reminders")
}

// Technician regular availability schedule
model TechnicianAvailability {
  id         String   @id @default(cuid())
  tenantId   String
  userId     String
  dayOfWeek  Int      // 0 = Sunday, 6 = Saturday
  startTime  String   // Format: "HH:mm" (e.g., "09:00")
  endTime    String   // Format: "HH:mm" (e.g., "17:00")
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([userId])
  @@index([dayOfWeek])
  @@unique([tenantId, userId, dayOfWeek])
  @@map("technician_availability")
}

// Time off / exceptions to regular schedule
model TimeOff {
  id        String   @id @default(cuid())
  tenantId  String
  userId    String
  startDate DateTime
  endDate   DateTime
  reason    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([userId])
  @@index([startDate, endDate])
  @@map("time_off")
}

// Voice AI call logs
model CallLog {
  id          String         @id @default(cuid())
  tenantId    String
  vapiCallId  String         @unique
  callerPhone String
  direction   CallDirection  @default(INBOUND)
  status      CallStatus     @default(QUEUED)
  duration    Int?           // Duration in seconds
  transcript  String?        @db.Text
  summary     String?
  metadata    Json?          // Store additional call data
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([vapiCallId])
  @@index([callerPhone])
  @@index([status])
  @@map("call_logs")
}

enum CallDirection {
  INBOUND
  OUTBOUND
}

enum CallStatus {
  QUEUED
  RINGING
  IN_PROGRESS
  FORWARDING
  ENDED
  FAILED
}

// Google Calendar Integration
model CalendarIntegration {
  id           String   @id @default(cuid())
  tenantId     String   @unique
  accessToken  String   @db.Text
  refreshToken String   @db.Text
  expiresAt    DateTime
  calendarId   String?  // Primary calendar ID to sync to
  syncEnabled  Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("calendar_integrations")
}

// Job tracking - extends appointments with work details
model Job {
  id            String    @id @default(cuid())
  tenantId      String
  appointmentId String    @unique
  technicianId  String?
  status        JobStatus @default(NOT_STARTED)
  startedAt     DateTime?
  completedAt   DateTime?
  notes         String?   @db.Text
  workSummary   String?   @db.Text  // Summary of work performed
  materialsUsed String?   @db.Text  // Materials/parts used
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  tenant      Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  technician  User?      @relation(fields: [technicianId], references: [id], onDelete: SetNull)
  photos      JobPhoto[]
  reviewRequest ReviewRequest?
  npsSurvey   NpsSurvey?

  @@index([tenantId])
  @@index([appointmentId])
  @@index([technicianId])
  @@index([status])
  @@map("jobs")
}

enum JobStatus {
  NOT_STARTED
  EN_ROUTE
  IN_PROGRESS
  ON_HOLD
  COMPLETED
  CANCELLED
}

// Photos attached to jobs
model JobPhoto {
  id          String        @id @default(cuid())
  jobId       String
  url         String        // S3 or storage URL
  key         String        // Storage key for deletion
  filename    String
  mimeType    String
  size        Int           // File size in bytes
  type        JobPhotoType  @default(DURING)
  caption     String?
  uploadedBy  String?       // User ID who uploaded
  createdAt   DateTime      @default(now())

  // Relations
  job Job @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@map("job_photos")
}

enum JobPhotoType {
  BEFORE
  DURING
  AFTER
}

// SMS Broadcast messages
model SmsBroadcast {
  id          String              @id @default(cuid())
  tenantId    String
  message     String              @db.Text
  sentBy      String              // User ID who sent
  recipientCount Int
  successCount   Int              @default(0)
  failureCount   Int              @default(0)
  status      BroadcastStatus     @default(PENDING)
  targetRoles UserRole[]          // Which roles to send to (empty = all)
  createdAt   DateTime            @default(now())
  completedAt DateTime?

  // Relations
  tenant    Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  recipients SmsBroadcastRecipient[]

  @@index([tenantId])
  @@index([status])
  @@map("sms_broadcasts")
}

model SmsBroadcastRecipient {
  id          String   @id @default(cuid())
  broadcastId String
  userId      String
  phone       String
  status      String   @default("pending") // pending, sent, failed
  error       String?
  sentAt      DateTime?

  // Relations
  broadcast SmsBroadcast @relation(fields: [broadcastId], references: [id], onDelete: Cascade)

  @@index([broadcastId])
  @@map("sms_broadcast_recipients")
}

enum BroadcastStatus {
  PENDING
  SENDING
  COMPLETED
  FAILED
}

// Tenant Settings
model TenantSettings {
  id                String   @id @default(cuid())
  tenantId          String   @unique
  businessHours     Json?    // { monday: { start: "09:00", end: "17:00" }, ... }
  timezone          String   @default("America/New_York")
  appointmentReminders Boolean @default(true)
  reminderHoursBefore Int     @default(24)
  autoConfirmBookings Boolean @default(false)
  reviewRequestEnabled Boolean @default(true)
  reviewRequestDelay  Int     @default(24) // Hours after job completion
  quoteFollowUpEnabled Boolean @default(true)
  depositRequired      Boolean @default(false)
  depositPercentage    Int     @default(50)
  lateFeeEnabled       Boolean @default(false)
  lateFeePercentage    Int     @default(5)
  paymentReminderEnabled Boolean @default(true)
  retentionEnabled       Boolean @default(true)
  retentionDormantDays   Int     @default(90)
  googleReviewUrl     String?
  yelpReviewUrl       String?
  facebookReviewUrl   String?
  reviewTimingHours   Int     @default(3)   // Hours after NPS to send review request
  reviewMaxPerDay     Int     @default(2)   // Max NPS-gated review requests per day
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  @@map("tenant_settings")
}

// Review Requests
model ReviewRequest {
  id          String   @id @default(cuid())
  tenantId    String
  jobId       String   @unique
  customerId  String
  status      ReviewRequestStatus @default(PENDING)
  sentAt      DateTime?
  clickedAt   DateTime?
  platform    String?  // "google", "yelp", or "facebook"
  npsScore    Int?
  npsGated    Boolean  @default(false)
  createdAt   DateTime @default(now())

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  job      Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([status])
  @@map("review_requests")
}

enum ReviewRequestStatus {
  PENDING
  SENT
  CLICKED
  SKIPPED
}

// ============================================
// Phase 2: AI Core Features
// ============================================

// Customer context for AI personalization
model CustomerContext {
  id              String   @id @default(cuid())
  tenantId        String
  customerId      String   @unique
  lastServiceType String?
  preferredTime   String?  // e.g., "morning", "afternoon", "evening"
  totalVisits     Int      @default(0)
  totalSpent      Decimal  @default(0) @db.Decimal(10, 2)
  aiSummary       String?  @db.Text  // AI-generated summary of customer history
  preferences     Json?    // Additional preferences (e.g., specific technician, communication style)
  lastInteraction DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@map("customer_contexts")
}

// Unified customer risk profile for AI insights
model CustomerRiskProfile {
  id                String    @id @default(cuid())
  tenantId          String
  customerId        String    @unique

  // Individual risk scores (0-100 scale)
  noShowRisk        Float     @default(0)   // Probability of no-showing (0-100)
  paymentRisk       Float     @default(0)   // Risk of late/non-payment (0-100)
  churnRisk         Float     @default(0)   // Probability of churning (0-100)

  // Composite score
  overallRisk       Float     @default(0)   // Weighted average (0-100)
  riskLevel         RiskLevel @default(LOW) // LOW, MEDIUM, HIGH, CRITICAL

  // Risk factors
  noShowFactors     Json?     // { noShowCount, daysSinceLastNoShow, appointmentHistory }
  paymentFactors    Json?     // { avgDaysLate, overdueCount, totalOwed }
  churnFactors      Json?     // { daysSinceLastVisit, visitFrequencyTrend, engagementScore }

  // AI insights
  aiRiskSummary     String?   @db.Text  // AI-generated risk summary
  recommendedAction String?   // Suggested next action
  actionPriority    Int       @default(0) // Priority for outreach (0 = lowest)

  // Historical tracking
  lastCalculatedAt  DateTime  @default(now())
  riskHistory       Json?     // Array of { date, noShowRisk, paymentRisk, churnRisk, overallRisk }

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  customer          Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@index([overallRisk])
  @@index([riskLevel])
  @@map("customer_risk_profiles")
}

enum RiskLevel {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// Outbound campaign management
model OutboundCampaign {
  id           String               @id @default(cuid())
  tenantId     String
  name         String
  type         OutboundCampaignType
  status       OutboundCampaignStatus @default(DRAFT)
  scheduledFor DateTime?
  completedAt  DateTime?
  targetCount  Int                  @default(0)
  successCount Int                  @default(0)
  failureCount Int                  @default(0)
  template     String?              @db.Text  // Message/call script template
  metadata     Json?                // Campaign-specific settings
  createdBy    String?
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  // Relations
  calls OutboundCall[]

  @@index([tenantId])
  @@index([status])
  @@index([scheduledFor])
  @@map("outbound_campaigns")
}

enum OutboundCampaignType {
  APPOINTMENT_REMINDER  // Remind about upcoming appointments
  FOLLOW_UP_SURVEY      // Post-job satisfaction survey
  PAYMENT_REMINDER      // Payment due reminders
  MAINTENANCE_REMINDER  // Scheduled maintenance reminders
  PROMOTIONAL           // Promotional campaigns
}

enum OutboundCampaignStatus {
  DRAFT
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  PAUSED
}

// Individual outbound calls within a campaign
model OutboundCall {
  id           String             @id @default(cuid())
  campaignId   String
  customerId   String
  customerPhone String
  status       OutboundCallStatus @default(PENDING)
  scheduledFor DateTime?
  attemptCount Int                @default(0)
  lastAttemptAt DateTime?
  completedAt  DateTime?
  vapiCallId   String?            // Link to Vapi call if initiated
  outcome      String?            // Call outcome (answered, voicemail, no_answer, etc.)
  notes        String?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  // Relations
  campaign OutboundCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@index([campaignId])
  @@index([customerId])
  @@index([status])
  @@index([scheduledFor])
  @@map("outbound_calls")
}

enum OutboundCallStatus {
  PENDING
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  FAILED
  SKIPPED
}

// Photo-based quote requests with AI analysis
model PhotoQuoteRequest {
  id                String              @id @default(cuid())
  tenantId          String
  customerId        String?
  customerPhone     String?
  customerEmail     String?
  photoUrl          String              // S3/storage URL of uploaded photo
  photoKey          String?             // Storage key for deletion
  aiAnalysis        Json?               // Full AI analysis response
  issueDescription  String?             // AI-identified issue description
  suggestedService  String?             // Recommended service type
  estimatedPriceMin Decimal?             @db.Decimal(10, 2) // Lower bound estimate
  estimatedPriceMax Decimal?             @db.Decimal(10, 2) // Upper bound estimate
  confidence        Float?              // AI confidence score (0-1)
  complexity        PhotoComplexity     @default(MEDIUM)
  status            PhotoQuoteStatus    @default(PENDING)
  customerNotes     String?             // Customer's description of the issue
  staffNotes        String?             // Staff follow-up notes
  convertedToQuote  String?             // Quote ID if converted
  expiresAt         DateTime
  viewedAt          DateTime?
  respondedAt       DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@index([tenantId])
  @@index([customerId])
  @@index([status])
  @@index([createdAt])
  @@map("photo_quote_requests")
}

enum PhotoQuoteStatus {
  PENDING       // Uploaded, waiting for AI analysis
  ANALYZING     // AI analysis in progress
  READY         // Analysis complete, awaiting customer response
  ACCEPTED      // Customer accepted the estimate
  REJECTED      // Customer declined
  CONVERTED     // Converted to formal quote
  EXPIRED       // Request expired
}

enum PhotoComplexity {
  SIMPLE        // Minor repair, quick fix
  MEDIUM        // Standard job
  COMPLEX       // Major repair, multiple issues
  REQUIRES_INSPECTION // Cannot estimate from photo alone
}

// ============================================
// Sprint 2.3: Smart Scheduling
// ============================================

// Customer scheduling preferences (learned from behavior)
model CustomerPreference {
  id                 String   @id @default(cuid())
  customerId         String   @unique
  tenantId           String
  preferredDays      Int[]    // 0=Sunday, 6=Saturday
  preferredTimeStart String?  // e.g., "09:00"
  preferredTimeEnd   String?  // e.g., "12:00"
  preferredTechnician String? // Preferred technician ID
  avoidDays          Int[]    // Days to avoid
  learningConfidence Float    @default(0)  // 0-1, increases with more data points
  dataPoints         Int      @default(0)  // Number of appointments used for learning
  lastUpdated        DateTime @default(now())
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@map("customer_preferences")
}

// Real-time technician location tracking
model TechnicianLocation {
  id         String   @id @default(cuid())
  userId     String
  tenantId   String
  latitude   Float
  longitude  Float
  accuracy   Float?   // GPS accuracy in meters
  heading    Float?   // Direction in degrees
  speed      Float?   // Speed in m/s
  status     TechnicianLocationStatus @default(IDLE)
  recordedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([userId])
  @@index([recordedAt])
  @@map("technician_locations")
}

enum TechnicianLocationStatus {
  IDLE        // Not on a job
  EN_ROUTE    // Traveling to customer
  ON_SITE     // At customer location
  BREAK       // On break
  OFFLINE     // Not tracking
}

// Customer address with geocoded coordinates
model CustomerLocation {
  id          String   @id @default(cuid())
  customerId  String   @unique
  tenantId    String
  address     String
  city        String?
  state       String?
  zipCode     String?
  country     String   @default("US")
  latitude    Float?
  longitude   Float?
  geocoded    Boolean  @default(false)
  geocodedAt  DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@map("customer_locations")
}

// Optimized route for a technician's day
model OptimizedRoute {
  id              String   @id @default(cuid())
  tenantId        String
  technicianId    String
  date            DateTime @db.Date
  totalDistance   Float?   // Total distance in km
  totalDuration   Int?     // Total duration in minutes
  stops           Json     // Array of stop objects with order
  optimizedAt     DateTime @default(now())
  appliedAt       DateTime?
  status          RouteStatus @default(PENDING)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([tenantId, technicianId, date])
  @@index([tenantId])
  @@index([technicianId])
  @@index([date])
  @@map("optimized_routes")
}

enum RouteStatus {
  PENDING     // Generated but not applied
  APPLIED     // Technician accepted route
  IN_PROGRESS // Route being executed
  COMPLETED   // All stops completed
  MODIFIED    // Manual changes made
}

// ============================================
// Phase 3: Customer Experience
// ============================================

// Customer authentication (separate from staff/Clerk auth)
model CustomerAuth {
  id               String   @id @default(cuid())
  customerId       String   @unique
  tenantId         String
  email            String?
  phone            String
  verificationCode String?
  codeExpiry       DateTime?
  magicLinkToken   String?  @unique
  magicLinkExpiry  DateTime?
  isVerified       Boolean  @default(false)
  lastLoginAt      DateTime?
  failedAttempts   Int      @default(0)
  lockedUntil      DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  sessions CustomerSession[]

  @@index([tenantId])
  @@index([customerId])
  @@index([phone])
  @@index([email])
  @@index([magicLinkToken])
  @@map("customer_auth")
}

// Customer portal sessions
model CustomerSession {
  id           String   @id @default(cuid())
  customerId   String
  customerAuthId String
  token        String   @unique
  userAgent    String?
  ipAddress    String?
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  customerAuth CustomerAuth @relation(fields: [customerAuthId], references: [id], onDelete: Cascade)

  @@index([customerId])
  @@index([token])
  @@map("customer_sessions")
}

// NPS Survey responses
model NpsSurvey {
  id            String   @id @default(cuid())
  tenantId      String
  jobId         String   @unique
  customerId    String
  score         Int?     // 1-10 NPS score
  feedback      String?  @db.Text
  sentAt        DateTime?
  respondedAt   DateTime?
  reviewClicked Boolean  @default(false)
  reviewPlatform String?  // "google", "yelp", etc.
  status        NpsSurveyStatus @default(PENDING)
  token         String   @unique
  createdAt     DateTime @default(now())

  job Job @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@index([status])
  @@index([token])
  @@map("nps_surveys")
}

enum NpsSurveyStatus {
  PENDING     // Not yet sent
  SENT        // Survey sent to customer
  RESPONDED   // Customer submitted score
  REVIEW_PROMPTED // Prompted for public review
  REVIEW_CLICKED  // Customer clicked review link
  EXPIRED     // Survey expired without response
}

// ============================================
// Phase 4: Advanced Features
// ============================================

// Sprint 4.1: Predictive Maintenance

// Customer equipment tracking
model CustomerEquipment {
  id              String              @id @default(cuid())
  tenantId        String
  customerId      String
  equipmentType   String              // e.g., "HVAC", "Water Heater", "Furnace"
  brand           String?
  model           String?
  serialNumber    String?
  installDate     DateTime?
  warrantyExpiry  DateTime?
  lastServiceDate DateTime?
  nextServiceDue  DateTime?
  condition       EquipmentCondition  @default(GOOD)
  notes           String?             @db.Text
  metadata        Json?               // Additional equipment-specific data
  isActive        Boolean             @default(true)
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  // Relations
  customer        Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  serviceHistory  EquipmentServiceHistory[]
  alerts          MaintenanceAlert[]

  @@index([tenantId])
  @@index([customerId])
  @@index([equipmentType])
  @@index([nextServiceDue])
  @@map("customer_equipment")
}

enum EquipmentCondition {
  EXCELLENT   // Like new
  GOOD        // Normal wear
  FAIR        // Needs attention soon
  POOR        // Requires immediate service
  CRITICAL    // Non-functional or unsafe
}

// Equipment service history
model EquipmentServiceHistory {
  id           String   @id @default(cuid())
  equipmentId  String
  tenantId     String
  jobId        String?  // Link to job if service was done through app
  serviceDate  DateTime
  serviceType  String   // e.g., "Routine Maintenance", "Repair", "Inspection"
  description  String?  @db.Text
  cost         Decimal? @db.Decimal(10, 2)
  partsReplaced String?  @db.Text
  technicianId String?
  technicianName String?
  condition    EquipmentCondition?  // Condition after service
  notes        String?  @db.Text
  createdAt    DateTime @default(now())

  equipment CustomerEquipment @relation(fields: [equipmentId], references: [id], onDelete: Cascade)

  @@index([equipmentId])
  @@index([tenantId])
  @@index([serviceDate])
  @@map("equipment_service_history")
}

// Maintenance alerts and predictions
model MaintenanceAlert {
  id           String              @id @default(cuid())
  tenantId     String
  customerId   String
  equipmentId  String?             // Optional link to specific equipment
  alertType    MaintenanceAlertType
  priority     AlertPriority       @default(MEDIUM)
  title        String
  description  String              @db.Text
  reasoning    String?             @db.Text  // AI reasoning for the prediction
  confidence   Float?              // AI confidence score (0-1)
  dueDate      DateTime?           // When maintenance should be performed
  dismissedAt  DateTime?
  dismissReason String?
  convertedToCampaign String?      // Campaign ID if converted to outreach
  status       MaintenanceAlertStatus @default(PENDING)
  metadata     Json?               // Alert-specific data
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt

  equipment CustomerEquipment? @relation(fields: [equipmentId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([customerId])
  @@index([equipmentId])
  @@index([status])
  @@index([priority])
  @@index([dueDate])
  @@map("maintenance_alerts")
}

enum MaintenanceAlertType {
  AGE_BASED           // Equipment reaching end of typical lifespan
  USAGE_BASED         // Based on usage patterns
  SEASONAL            // Seasonal maintenance (e.g., HVAC before summer)
  WARRANTY_EXPIRING   // Warranty about to expire
  OVERDUE_SERVICE     // Missed scheduled service
  AI_PREDICTED        // AI-detected potential issue
  RECALL              // Product recall or safety issue
  EFFICIENCY          // Efficiency degradation detected
}

enum AlertPriority {
  LOW       // Informational, can wait
  MEDIUM    // Should be addressed within weeks
  HIGH      // Should be addressed soon
  URGENT    // Requires immediate attention
}

enum MaintenanceAlertStatus {
  PENDING     // Alert created, awaiting action
  NOTIFIED    // Customer has been notified
  SCHEDULED   // Maintenance appointment scheduled
  IN_PROGRESS // Work in progress
  COMPLETED   // Maintenance completed
  DISMISSED   // Alert dismissed (not needed)
  EXPIRED     // Alert expired without action
}

// Sprint 4.2: Dynamic Pricing

// Demand metrics for pricing calculations
model DemandMetrics {
  id           String   @id @default(cuid())
  tenantId     String
  date         DateTime @db.Date
  hour         Int?     // 0-23, null for daily aggregate
  dayOfWeek    Int?     // 0-6, Sunday to Saturday
  bookingCount Int      @default(0)
  completedJobs Int     @default(0)
  cancelledJobs Int     @default(0)
  capacityUsed Float    @default(0)  // Percentage of available slots used
  revenue      Decimal  @default(0) @db.Decimal(10, 2)
  avgJobDuration Int?   // Average job duration in minutes
  peakHour     Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([tenantId, date, hour])
  @@index([tenantId])
  @@index([date])
  @@index([dayOfWeek])
  @@map("demand_metrics")
}

// Pricing rules for dynamic pricing
model PricingRule {
  id            String          @id @default(cuid())
  tenantId      String
  name          String
  description   String?
  ruleType      PricingRuleType
  conditions    Json            // Rule conditions (time, demand, urgency, etc.)
  multiplierMin Decimal         @default(1.0) @db.Decimal(5, 2)  // Minimum multiplier
  multiplierMax Decimal         @default(1.5) @db.Decimal(5, 2)  // Maximum multiplier
  flatAdjustment Decimal?       @db.Decimal(10, 2) // Flat fee adjustment (optional)
  priority      Int             @default(0)    // Higher priority rules apply first
  isActive      Boolean         @default(true)
  startsAt      DateTime?       // Optional rule validity period
  endsAt        DateTime?
  appliedCount  Int             @default(0)    // How many times this rule was applied
  totalRevenue  Decimal         @default(0) @db.Decimal(10, 2)    // Revenue attributed to this rule
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  @@index([tenantId])
  @@index([ruleType])
  @@index([isActive])
  @@index([priority])
  @@map("pricing_rules")
}

enum PricingRuleType {
  TIME_OF_DAY       // Different prices for morning/afternoon/evening
  DAY_OF_WEEK       // Weekend vs weekday pricing
  DEMAND_BASED      // Price increases with demand
  URGENCY           // Emergency/urgent service premium
  SEASONAL          // Holiday or seasonal pricing
  EARLY_BIRD        // Discount for booking in advance
  LOYALTY           // Customer loyalty discounts
  PROMOTIONAL       // Promotional pricing campaigns
}

// Service pricing configuration
model ServicePricing {
  id              String   @id @default(cuid())
  tenantId        String
  serviceId       String
  basePrice       Decimal  @db.Decimal(10, 2)
  minPrice        Decimal? @db.Decimal(10, 2)   // Floor price
  maxPrice        Decimal? @db.Decimal(10, 2)   // Ceiling price
  urgentMultiplier Decimal @default(1.5) @db.Decimal(5, 2)  // Standard urgency multiplier
  emergencyMultiplier Decimal @default(2.0) @db.Decimal(5, 2) // Emergency multiplier
  dynamicPricingEnabled Boolean @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([tenantId, serviceId])
  @@index([tenantId])
  @@index([serviceId])
  @@map("service_pricing")
}

// Price quote history for auditing
model PriceQuoteHistory {
  id              String   @id @default(cuid())
  tenantId        String
  customerId      String?
  serviceId       String?
  basePrice       Decimal  @db.Decimal(10, 2)
  finalPrice      Decimal  @db.Decimal(10, 2)
  appliedRules    Json     // Array of rule IDs and their effects
  urgencyLevel    UrgencyLevel @default(STANDARD)
  demandFactor    Float    @default(1.0)
  requestedAt     DateTime
  scheduledFor    DateTime?
  converted       Boolean  @default(false)  // Whether this led to a booking
  createdAt       DateTime @default(now())

  @@index([tenantId])
  @@index([customerId])
  @@index([serviceId])
  @@index([requestedAt])
  @@map("price_quote_history")
}

enum UrgencyLevel {
  STANDARD      // Normal booking
  NEXT_DAY      // Next day service
  SAME_DAY      // Same day service
  URGENT        // Within hours
  EMERGENCY     // Immediate response
}

// Sprint 4.3: WhatsApp & Unified Messaging

// Customer messaging channels
model MessageChannel {
  id         String         @id @default(cuid())
  tenantId   String
  customerId String
  channel    ChannelType
  channelId  String         // Phone number for SMS/WhatsApp, email for email
  isActive   Boolean        @default(true)
  isVerified Boolean        @default(false)
  verifiedAt DateTime?
  preferences Json?         // Channel-specific preferences
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  @@unique([tenantId, customerId, channel])
  @@index([tenantId])
  @@index([customerId])
  @@index([channel])
  @@map("message_channels")
}

enum ChannelType {
  SMS
  WHATSAPP
  EMAIL
  IMESSAGE
}

// Conversation threads
model ConversationThread {
  id             String             @id @default(cuid())
  tenantId       String
  customerId     String
  customerName   String?
  customerPhone  String
  channel        ChannelType
  status         ConversationStatus @default(OPEN)
  priority       ConversationPriority @default(NORMAL)
  assignedTo     String?            // Staff user ID
  subject        String?
  lastMessageAt  DateTime?
  lastMessagePreview String?
  unreadCount    Int               @default(0)
  tags           String[]
  metadata       Json?
  closedAt       DateTime?
  closedBy       String?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  messages Message[]
  classifications MessageClassification[]

  @@index([tenantId])
  @@index([customerId])
  @@index([status])
  @@index([assignedTo])
  @@index([lastMessageAt])
  @@map("conversation_threads")
}

enum ConversationStatus {
  OPEN          // Active conversation
  PENDING       // Awaiting response
  RESOLVED      // Completed/resolved
  CLOSED        // Closed without resolution
  SPAM          // Marked as spam
}

enum ConversationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// Individual messages
model Message {
  id           String           @id @default(cuid())
  threadId     String
  tenantId     String
  direction    MessageDirection
  content      String           @db.Text
  contentType  MessageContentType @default(TEXT)
  mediaUrl     String?
  mediaType    String?          // MIME type
  mediaSize    Int?             // Size in bytes
  status       MessageStatus    @default(PENDING)
  sentAt       DateTime?
  deliveredAt  DateTime?
  readAt       DateTime?
  failedAt     DateTime?
  failureReason String?
  externalId   String?          // Twilio message SID, WhatsApp ID, etc.
  senderName   String?
  senderPhone  String?
  metadata     Json?
  createdAt    DateTime         @default(now())

  thread ConversationThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@index([threadId])
  @@index([tenantId])
  @@index([direction])
  @@index([status])
  @@index([createdAt])
  @@map("messages")
}

enum MessageDirection {
  INBOUND    // From customer
  OUTBOUND   // To customer
}

enum MessageContentType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  LOCATION
  CONTACT
  TEMPLATE     // WhatsApp template message
}

enum MessageStatus {
  PENDING      // Not yet sent
  QUEUED       // In send queue
  SENT         // Sent to provider
  DELIVERED    // Delivered to recipient
  READ         // Read by recipient
  FAILED       // Failed to send
}

// WhatsApp message templates (required by WhatsApp Business API)
model WhatsAppTemplate {
  id            String               @id @default(cuid())
  tenantId      String
  name          String               // Template name (alphanumeric + underscore only)
  language      String               @default("en")
  category      WhatsAppTemplateCategory
  status        WhatsAppTemplateStatus @default(DRAFT)
  headerType    String?              // TEXT, IMAGE, VIDEO, DOCUMENT
  headerContent String?
  bodyText      String               @db.Text
  footerText    String?
  buttons       Json?                // Array of button configurations
  exampleValues Json?                // Sample values for template variables
  whatsappId    String?              // Template ID from WhatsApp
  submittedAt   DateTime?
  approvedAt    DateTime?
  rejectedAt    DateTime?
  rejectionReason String?
  usageCount    Int                  @default(0)
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt

  @@unique([tenantId, name, language])
  @@index([tenantId])
  @@index([category])
  @@index([status])
  @@map("whatsapp_templates")
}

enum WhatsAppTemplateCategory {
  MARKETING        // Promotional messages
  UTILITY          // Transactional messages (confirmations, reminders)
  AUTHENTICATION   // OTP and verification codes
}

enum WhatsAppTemplateStatus {
  DRAFT            // Not yet submitted
  PENDING          // Submitted, awaiting approval
  APPROVED         // Approved for use
  REJECTED         // Rejected by WhatsApp
  DISABLED         // Disabled by tenant
}

// Quick reply templates for agents
model QuickReply {
  id           String   @id @default(cuid())
  tenantId     String
  title        String   // Short title for display
  content      String   @db.Text
  category     String?  // Grouping category
  shortcut     String?  // Keyboard shortcut (e.g., "/greeting")
  channels     ChannelType[]  // Which channels this can be used on
  usageCount   Int      @default(0)
  createdBy    String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([tenantId])
  @@index([category])
  @@index([shortcut])
  @@map("quick_replies")
}

// ============================================
// Sprint 7.0: AI Engine Foundation
// ============================================

enum AiFeedbackAction {
  ACCEPTED
  EDITED
  REJECTED
}

// Track every Claude API call per tenant per feature
model AiUsageLog {
  id           String   @id @default(cuid())
  tenantId     String
  feature      String
  template     String
  inputTokens  Int
  outputTokens Int
  costCents    Int
  latencyMs    Int
  success      Boolean
  errorMessage String?  @db.Text
  createdAt    DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([tenantId, feature])
  @@index([createdAt])
  @@map("ai_usage_logs")
}

// Track human feedback on AI-generated outputs
model AiFeedback {
  id        String           @id @default(cuid())
  tenantId  String
  feature   String
  template  String
  aiOutput  String           @db.Text
  action    AiFeedbackAction
  humanEdit String?          @db.Text
  createdAt DateTime         @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([tenantId, feature])
  @@index([createdAt])
  @@map("ai_feedback")
}

// Customer retention campaigns (win-back sequences)
model RetentionCampaign {
  id           String    @id @default(cuid())
  tenantId     String
  customerId   String
  type         String    // DORMANT_WINBACK, SEASONAL, MAINTENANCE
  step         Int
  channel      String    // SMS, EMAIL, BOTH
  scheduledAt  DateTime
  sentAt       DateTime?
  status       String    @default("PENDING") // PENDING, SENT, CANCELLED, FAILED
  discountCode String?
  message      String?   @db.Text
  createdAt    DateTime  @default(now())

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@index([status, scheduledAt])
  @@index([tenantId, type])
  @@map("retention_campaigns")
}

// Service maintenance intervals
model ServiceInterval {
  id           String   @id @default(cuid())
  tenantId     String
  serviceId    String   @unique
  intervalDays Int
  reminderDays Int      @default(14)
  createdAt    DateTime @default(now())

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([tenantId, serviceId])
  @@index([tenantId])
  @@map("service_intervals")
}

// ============================================
// Sprint 7.6: Smart Dispatch & Route Optimization
// ============================================

// Technician skill levels for service matching
model TechnicianSkill {
  id        String     @id @default(cuid())
  tenantId  String
  userId    String
  serviceId String
  level     SkillLevel @default(INTERMEDIATE)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([userId, serviceId])
  @@index([tenantId])
  @@index([userId])
  @@index([serviceId])
  @@index([tenantId, serviceId])
  @@map("technician_skills")
}

// ============================================
// Sprint 7.7: Communication Intelligence
// ============================================

enum MessageIntent {
  INQUIRY
  BOOKING_REQUEST
  RESCHEDULE_REQUEST
  CANCELLATION_REQUEST
  COMPLAINT
  FEEDBACK
  EMERGENCY
  FOLLOW_UP
  GENERAL
}

enum MessageSentiment {
  POSITIVE
  NEUTRAL
  NEGATIVE
  URGENT
}

// AI classification of inbound messages
model MessageClassification {
  id             String           @id @default(cuid())
  tenantId       String
  conversationId String
  messageId      String           @unique
  intent         MessageIntent
  sentiment      MessageSentiment
  confidence     Float
  urgencyScore   Int              @default(0) // 0-100
  keywords       String[]
  suggestedRoute String?          // e.g., "sales", "support", "scheduling"
  processedAt    DateTime         @default(now())

  tenant         Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  conversation   ConversationThread @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([conversationId])
  @@index([intent])
  @@index([sentiment])
  @@index([urgencyScore])
  @@map("message_classifications")
}

// Configurable auto-responder rules
model AutoResponderRule {
  id               String            @id @default(cuid())
  tenantId         String
  name             String
  intent           MessageIntent?    // null = any intent
  sentiment        MessageSentiment? // null = any sentiment
  minUrgency       Int               @default(0)
  maxUrgency       Int               @default(100)
  responseTemplate String            @db.Text
  isActive         Boolean           @default(true)
  priority         Int               @default(0) // higher = checked first
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  tenant           Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([isActive])
  @@index([intent])
  @@map("auto_responder_rules")
}

// ============================================
// Sprint 7.8: AI Business Copilot
// ============================================

// AI Copilot conversation history
model CopilotConversation {
  id        String   @id @default(cuid())
  tenantId  String
  userId    String
  messages  Json     // Array of {role, content, toolCalls, toolResults}
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([tenantId, userId])
  @@map("copilot_conversations")
}

// Weekly AI-generated business reports
model WeeklyReport {
  id        String    @id @default(cuid())
  tenantId  String
  weekStart DateTime  @db.Date
  report    Json      // Structured report: metrics, wins, actions, forecast
  sent      Boolean   @default(false)
  sentAt    DateTime?
  createdAt DateTime  @default(now())

  tenant    Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, weekStart])
  @@index([tenantId])
  @@map("weekly_reports")
}

// ============================================
// AI Specialist Agents
// ============================================

enum AgentType {
  REVENUE_SALES
  CUSTOMER_SUCCESS
  OPERATIONS
  MARKETING
}

enum InsightPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum InsightStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

// AI-generated insights from specialist agents
model AgentInsight {
  id                String          @id @default(cuid())
  tenantId          String
  agentType         AgentType
  entityType        String          // "quote", "customer", "appointment", "campaign"
  entityId          String
  insightType       String          // "follow_up_urgency", "churn_risk", "no_show_risk", etc.
  title             String
  description       String          @db.Text
  confidenceScore   Float           // 0.0-1.0
  impactScore       Float           // 0.0-1.0
  priority          InsightPriority
  recommendedAction String          @db.Text
  actionParams      Json?           // Parameters for executing the action
  actionLabel       String          // Button label e.g., "Call Now", "Send Reminder"
  status            InsightStatus   @default(PENDING)
  expiresAt         DateTime?
  aiReasoning       String?         @db.Text  // AI explanation of the insight
  approvedAt        DateTime?
  approvedBy        String?
  rejectedAt        DateTime?
  rejectedBy        String?
  rejectionReason   String?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  tenant            Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([tenantId, agentType])
  @@index([tenantId, status])
  @@index([tenantId, priority])
  @@index([entityType, entityId])
  @@index([expiresAt])
  @@map("agent_insights")
}

// Track agent execution runs
model AgentRun {
  id                String    @id @default(cuid())
  tenantId          String
  agentType         AgentType
  triggeredBy       String    // "schedule", "event", "manual"
  triggerEvent      String?   // Event name if triggered by event
  entitiesAnalyzed  Int       @default(0)
  insightsGenerated Int       @default(0)
  status            String    @default("RUNNING") // RUNNING, COMPLETED, FAILED
  errorMessage      String?   @db.Text
  totalInputTokens  Int       @default(0)
  totalOutputTokens Int       @default(0)
  costCents         Int       @default(0)
  durationMs        Int?
  startedAt         DateTime  @default(now())
  completedAt       DateTime?
  createdAt         DateTime  @default(now())

  @@index([tenantId])
  @@index([tenantId, agentType])
  @@index([status])
  @@index([startedAt])
  @@map("agent_runs")
}

// Per-tenant agent configuration
model AgentSettings {
  id                      String          @id @default(cuid())
  tenantId                String          @unique

  // Agent enable/disable
  revenueAgentEnabled     Boolean         @default(true)
  customerAgentEnabled    Boolean         @default(true)
  operationsAgentEnabled  Boolean         @default(true)
  marketingAgentEnabled   Boolean         @default(true)

  // Notification settings
  dashboardNotifications  Boolean         @default(true)
  pushNotifications       Boolean         @default(true)
  pushMinPriority         InsightPriority @default(HIGH)
  emailDigestEnabled      Boolean         @default(true)
  emailDigestFrequency    String          @default("DAILY") // DAILY, WEEKLY
  emailDigestRecipients   String[]        // User IDs to receive digests

  // Agent schedule configuration
  revenueAgentSchedule    String          @default("0 8 * * *")  // Daily at 8am
  customerAgentSchedule   String          @default("0 9 * * *")  // Daily at 9am
  operationsAgentSchedule String          @default("0 20 * * *") // Nightly at 8pm
  marketingAgentSchedule  String          @default("0 10 * * 1") // Weekly Monday 10am

  createdAt               DateTime        @default(now())
  updatedAt               DateTime        @updatedAt

  @@map("agent_settings")
}
