// Prisma Schema for Smart Business Assistant
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Multi-tenancy: Each business is a tenant
model Tenant {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  email     String   @unique
  phone     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  users        User[]
  customers    Customer[]
  services     Service[]
  appointments Appointment[]
  quotes       Quote[]
  invoices     Invoice[]
  availability TechnicianAvailability[]
  timeOff      TimeOff[]
  callLogs     CallLog[]
  invitations  TeamInvitation[]
  jobs         Job[]
  smsBroadcasts SmsBroadcast[]
  settings     TenantSettings?
  reviewRequests ReviewRequest[]

  @@map("tenants")
}

// Users belong to tenants (staff/admin)
model User {
  id        String     @id @default(cuid())
  email     String     @unique
  password  String?
  name      String
  phone     String?
  role      UserRole   @default(TECHNICIAN)
  status    UserStatus @default(ACTIVE)
  tenantId  String
  clerkId   String?    @unique
  invitedBy String?
  joinedAt  DateTime?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // Relations
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointments Appointment[]
  availability TechnicianAvailability[]
  timeOff      TimeOff[]
  jobs         Job[]
  locations    TechnicianLocation[]

  @@index([tenantId])
  @@index([clerkId])
  @@index([status])
  @@map("users")
}

enum UserRole {
  OWNER      // Business owner, full access
  ADMIN      // Admin access, can manage team
  DISPATCHER // Can manage appointments and customers
  TECHNICIAN // Field worker, limited access
}

enum UserStatus {
  PENDING    // Invited but not yet joined
  ACTIVE     // Active team member
  DEACTIVATED // Removed from team
}

// Team invitations
model TeamInvitation {
  id        String           @id @default(cuid())
  email     String
  name      String?
  role      UserRole         @default(TECHNICIAN)
  tenantId  String
  token     String           @unique
  status    InvitationStatus @default(PENDING)
  expiresAt DateTime
  invitedBy String
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, email])
  @@index([token])
  @@index([tenantId])
  @@map("team_invitations")
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

// Customers are tenant-specific
model Customer {
  id        String   @id @default(cuid())
  name      String
  email     String?
  phone     String
  address   String?
  notes     String?
  tenantId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointments Appointment[]
  quotes       Quote[]
  invoices     Invoice[]
  reviewRequests ReviewRequest[]
  context      CustomerContext?
  preferences  CustomerPreference?
  location     CustomerLocation?
  auth         CustomerAuth?
  equipment    CustomerEquipment[]

  @@index([tenantId])
  @@index([phone])
  @@map("customers")
}

// Services catalog
model Service {
  id              String        @id @default(cuid())
  name            String
  description     String?
  durationMinutes Int           @default(60)
  price           Float?
  tenantId        String
  // Availability settings
  bufferMinutes   Int           @default(0)      // Buffer time after appointment
  maxPerDay       Int?                            // Max appointments per day (null = unlimited)
  leadTimeHours   Int           @default(24)     // Minimum hours before appointment can be booked
  isActive        Boolean       @default(true)   // Whether service accepts bookings
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointments Appointment[]
  availability ServiceAvailability[]

  @@index([tenantId])
  @@map("services")
}

// Service-specific availability windows
model ServiceAvailability {
  id         String   @id @default(cuid())
  serviceId  String
  dayOfWeek  Int      // 0 = Sunday, 6 = Saturday
  startTime  String   // Format: "HH:mm" (e.g., "09:00")
  endTime    String   // Format: "HH:mm" (e.g., "17:00")
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([serviceId, dayOfWeek])
  @@index([serviceId])
  @@map("service_availability")
}

// Appointments for services
model Appointment {
  id                String            @id @default(cuid())
  customerId        String
  serviceId         String?
  assignedTo        String?
  scheduledAt       DateTime
  duration          Int               @default(60)
  status            AppointmentStatus @default(SCHEDULED)
  notes             String?
  tenantId          String
  confirmationCode  String?           @unique
  manageToken       String?           @unique  // Token for customer to manage their booking
  cancelledAt       DateTime?
  cancelReason      String?
  googleCalendarEventId String?       // Google Calendar event ID for sync
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // Relations
  tenant       Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer     Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  service      Service? @relation(fields: [serviceId], references: [id], onDelete: SetNull)
  assignedUser User?    @relation(fields: [assignedTo], references: [id], onDelete: SetNull)
  job          Job?

  @@index([tenantId])
  @@index([customerId])
  @@index([scheduledAt])
  @@index([assignedTo])
  @@index([status])
  @@index([manageToken])
  @@map("appointments")
}

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// Quotes/Estimates
model Quote {
  id          String      @id @default(cuid())
  quoteNumber String      @unique
  description String
  amount      Float
  validUntil  DateTime
  status      QuoteStatus @default(DRAFT)
  customerId  String
  tenantId    String
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  items    QuoteItem[]

  @@index([tenantId])
  @@index([customerId])
  @@map("quotes")
}

enum QuoteStatus {
  DRAFT
  SENT
  ACCEPTED
  REJECTED
  EXPIRED
}

model QuoteItem {
  id          String   @id @default(cuid())
  description String
  quantity    Int
  unitPrice   Float
  total       Float
  quoteId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  quote Quote @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  @@index([quoteId])
  @@map("quote_items")
}

// Invoices
model Invoice {
  id            String        @id @default(cuid())
  invoiceNumber String        @unique
  description   String
  amount        Float
  paidAmount    Float         @default(0)
  status        InvoiceStatus @default(DRAFT)
  dueDate       DateTime
  paidAt        DateTime?
  sentAt        DateTime?
  customerId    String
  quoteId       String?
  tenantId      String
  stripePaymentIntentId String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Relations
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  items    InvoiceItem[]

  @@index([tenantId])
  @@index([customerId])
  @@index([quoteId])
  @@map("invoices")
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
  CANCELLED
}

model InvoiceItem {
  id          String   @id @default(cuid())
  description String
  quantity    Int
  unitPrice   Float
  total       Float
  invoiceId   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@map("invoice_items")
}

// Technician regular availability schedule
model TechnicianAvailability {
  id         String   @id @default(cuid())
  tenantId   String
  userId     String
  dayOfWeek  Int      // 0 = Sunday, 6 = Saturday
  startTime  String   // Format: "HH:mm" (e.g., "09:00")
  endTime    String   // Format: "HH:mm" (e.g., "17:00")
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([userId])
  @@index([dayOfWeek])
  @@unique([tenantId, userId, dayOfWeek])
  @@map("technician_availability")
}

// Time off / exceptions to regular schedule
model TimeOff {
  id        String   @id @default(cuid())
  tenantId  String
  userId    String
  startDate DateTime
  endDate   DateTime
  reason    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([userId])
  @@index([startDate, endDate])
  @@map("time_off")
}

// Voice AI call logs
model CallLog {
  id          String         @id @default(cuid())
  tenantId    String
  vapiCallId  String         @unique
  callerPhone String
  direction   CallDirection  @default(INBOUND)
  status      CallStatus     @default(QUEUED)
  duration    Int?           // Duration in seconds
  transcript  String?        @db.Text
  summary     String?
  metadata    Json?          // Store additional call data
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([vapiCallId])
  @@index([callerPhone])
  @@index([status])
  @@map("call_logs")
}

enum CallDirection {
  INBOUND
  OUTBOUND
}

enum CallStatus {
  QUEUED
  RINGING
  IN_PROGRESS
  FORWARDING
  ENDED
  FAILED
}

// Google Calendar Integration
model CalendarIntegration {
  id           String   @id @default(cuid())
  tenantId     String   @unique
  accessToken  String   @db.Text
  refreshToken String   @db.Text
  expiresAt    DateTime
  calendarId   String?  // Primary calendar ID to sync to
  syncEnabled  Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("calendar_integrations")
}

// Job tracking - extends appointments with work details
model Job {
  id            String    @id @default(cuid())
  tenantId      String
  appointmentId String    @unique
  technicianId  String?
  status        JobStatus @default(NOT_STARTED)
  startedAt     DateTime?
  completedAt   DateTime?
  notes         String?   @db.Text
  workSummary   String?   @db.Text  // Summary of work performed
  materialsUsed String?   @db.Text  // Materials/parts used
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  tenant      Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  technician  User?      @relation(fields: [technicianId], references: [id], onDelete: SetNull)
  photos      JobPhoto[]
  reviewRequest ReviewRequest?
  npsSurvey   NpsSurvey?

  @@index([tenantId])
  @@index([appointmentId])
  @@index([technicianId])
  @@index([status])
  @@map("jobs")
}

enum JobStatus {
  NOT_STARTED
  EN_ROUTE
  IN_PROGRESS
  ON_HOLD
  COMPLETED
  CANCELLED
}

// Photos attached to jobs
model JobPhoto {
  id          String        @id @default(cuid())
  jobId       String
  url         String        // S3 or storage URL
  key         String        // Storage key for deletion
  filename    String
  mimeType    String
  size        Int           // File size in bytes
  type        JobPhotoType  @default(DURING)
  caption     String?
  uploadedBy  String?       // User ID who uploaded
  createdAt   DateTime      @default(now())

  // Relations
  job Job @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@map("job_photos")
}

enum JobPhotoType {
  BEFORE
  DURING
  AFTER
}

// SMS Broadcast messages
model SmsBroadcast {
  id          String              @id @default(cuid())
  tenantId    String
  message     String              @db.Text
  sentBy      String              // User ID who sent
  recipientCount Int
  successCount   Int              @default(0)
  failureCount   Int              @default(0)
  status      BroadcastStatus     @default(PENDING)
  targetRoles UserRole[]          // Which roles to send to (empty = all)
  createdAt   DateTime            @default(now())
  completedAt DateTime?

  // Relations
  tenant    Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  recipients SmsBroadcastRecipient[]

  @@index([tenantId])
  @@index([status])
  @@map("sms_broadcasts")
}

model SmsBroadcastRecipient {
  id          String   @id @default(cuid())
  broadcastId String
  userId      String
  phone       String
  status      String   @default("pending") // pending, sent, failed
  error       String?
  sentAt      DateTime?

  // Relations
  broadcast SmsBroadcast @relation(fields: [broadcastId], references: [id], onDelete: Cascade)

  @@index([broadcastId])
  @@map("sms_broadcast_recipients")
}

enum BroadcastStatus {
  PENDING
  SENDING
  COMPLETED
  FAILED
}

// Tenant Settings
model TenantSettings {
  id                String   @id @default(cuid())
  tenantId          String   @unique
  businessHours     Json?    // { monday: { start: "09:00", end: "17:00" }, ... }
  timezone          String   @default("America/New_York")
  appointmentReminders Boolean @default(true)
  reminderHoursBefore Int     @default(24)
  autoConfirmBookings Boolean @default(false)
  reviewRequestEnabled Boolean @default(true)
  reviewRequestDelay  Int     @default(24) // Hours after job completion
  googleReviewUrl     String?
  yelpReviewUrl       String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  @@map("tenant_settings")
}

// Review Requests
model ReviewRequest {
  id          String   @id @default(cuid())
  tenantId    String
  jobId       String   @unique
  customerId  String
  status      ReviewRequestStatus @default(PENDING)
  sentAt      DateTime?
  clickedAt   DateTime?
  platform    String?  // "google" or "yelp"
  createdAt   DateTime @default(now())

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  job      Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([status])
  @@map("review_requests")
}

enum ReviewRequestStatus {
  PENDING
  SENT
  CLICKED
  SKIPPED
}

// ============================================
// Phase 2: AI Core Features
// ============================================

// Customer context for AI personalization
model CustomerContext {
  id              String   @id @default(cuid())
  tenantId        String
  customerId      String   @unique
  lastServiceType String?
  preferredTime   String?  // e.g., "morning", "afternoon", "evening"
  totalVisits     Int      @default(0)
  totalSpent      Float    @default(0)
  aiSummary       String?  @db.Text  // AI-generated summary of customer history
  preferences     Json?    // Additional preferences (e.g., specific technician, communication style)
  lastInteraction DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@map("customer_contexts")
}

// Outbound campaign management
model OutboundCampaign {
  id           String               @id @default(cuid())
  tenantId     String
  name         String
  type         OutboundCampaignType
  status       OutboundCampaignStatus @default(DRAFT)
  scheduledFor DateTime?
  completedAt  DateTime?
  targetCount  Int                  @default(0)
  successCount Int                  @default(0)
  failureCount Int                  @default(0)
  template     String?              @db.Text  // Message/call script template
  metadata     Json?                // Campaign-specific settings
  createdBy    String?
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  // Relations
  calls OutboundCall[]

  @@index([tenantId])
  @@index([status])
  @@index([scheduledFor])
  @@map("outbound_campaigns")
}

enum OutboundCampaignType {
  APPOINTMENT_REMINDER  // Remind about upcoming appointments
  FOLLOW_UP_SURVEY      // Post-job satisfaction survey
  PAYMENT_REMINDER      // Payment due reminders
  MAINTENANCE_REMINDER  // Scheduled maintenance reminders
  PROMOTIONAL           // Promotional campaigns
}

enum OutboundCampaignStatus {
  DRAFT
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  PAUSED
}

// Individual outbound calls within a campaign
model OutboundCall {
  id           String             @id @default(cuid())
  campaignId   String
  customerId   String
  customerPhone String
  status       OutboundCallStatus @default(PENDING)
  scheduledFor DateTime?
  attemptCount Int                @default(0)
  lastAttemptAt DateTime?
  completedAt  DateTime?
  vapiCallId   String?            // Link to Vapi call if initiated
  outcome      String?            // Call outcome (answered, voicemail, no_answer, etc.)
  notes        String?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  // Relations
  campaign OutboundCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@index([campaignId])
  @@index([customerId])
  @@index([status])
  @@index([scheduledFor])
  @@map("outbound_calls")
}

enum OutboundCallStatus {
  PENDING
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  FAILED
  SKIPPED
}

// Photo-based quote requests with AI analysis
model PhotoQuoteRequest {
  id                String              @id @default(cuid())
  tenantId          String
  customerId        String?
  customerPhone     String?
  customerEmail     String?
  photoUrl          String              // S3/storage URL of uploaded photo
  photoKey          String?             // Storage key for deletion
  aiAnalysis        Json?               // Full AI analysis response
  issueDescription  String?             // AI-identified issue description
  suggestedService  String?             // Recommended service type
  estimatedPriceMin Float?              // Lower bound estimate
  estimatedPriceMax Float?              // Upper bound estimate
  confidence        Float?              // AI confidence score (0-1)
  complexity        PhotoComplexity     @default(MEDIUM)
  status            PhotoQuoteStatus    @default(PENDING)
  customerNotes     String?             // Customer's description of the issue
  staffNotes        String?             // Staff follow-up notes
  convertedToQuote  String?             // Quote ID if converted
  expiresAt         DateTime
  viewedAt          DateTime?
  respondedAt       DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@index([tenantId])
  @@index([customerId])
  @@index([status])
  @@index([createdAt])
  @@map("photo_quote_requests")
}

enum PhotoQuoteStatus {
  PENDING       // Uploaded, waiting for AI analysis
  ANALYZING     // AI analysis in progress
  READY         // Analysis complete, awaiting customer response
  ACCEPTED      // Customer accepted the estimate
  REJECTED      // Customer declined
  CONVERTED     // Converted to formal quote
  EXPIRED       // Request expired
}

enum PhotoComplexity {
  SIMPLE        // Minor repair, quick fix
  MEDIUM        // Standard job
  COMPLEX       // Major repair, multiple issues
  REQUIRES_INSPECTION // Cannot estimate from photo alone
}

// ============================================
// Sprint 2.3: Smart Scheduling
// ============================================

// Customer scheduling preferences (learned from behavior)
model CustomerPreference {
  id                 String   @id @default(cuid())
  customerId         String   @unique
  tenantId           String
  preferredDays      Int[]    // 0=Sunday, 6=Saturday
  preferredTimeStart String?  // e.g., "09:00"
  preferredTimeEnd   String?  // e.g., "12:00"
  preferredTechnician String? // Preferred technician ID
  avoidDays          Int[]    // Days to avoid
  learningConfidence Float    @default(0)  // 0-1, increases with more data points
  dataPoints         Int      @default(0)  // Number of appointments used for learning
  lastUpdated        DateTime @default(now())
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@map("customer_preferences")
}

// Real-time technician location tracking
model TechnicianLocation {
  id         String   @id @default(cuid())
  userId     String
  tenantId   String
  latitude   Float
  longitude  Float
  accuracy   Float?   // GPS accuracy in meters
  heading    Float?   // Direction in degrees
  speed      Float?   // Speed in m/s
  status     TechnicianLocationStatus @default(IDLE)
  recordedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([userId])
  @@index([recordedAt])
  @@map("technician_locations")
}

enum TechnicianLocationStatus {
  IDLE        // Not on a job
  EN_ROUTE    // Traveling to customer
  ON_SITE     // At customer location
  BREAK       // On break
  OFFLINE     // Not tracking
}

// Customer address with geocoded coordinates
model CustomerLocation {
  id          String   @id @default(cuid())
  customerId  String   @unique
  tenantId    String
  address     String
  city        String?
  state       String?
  zipCode     String?
  country     String   @default("US")
  latitude    Float?
  longitude   Float?
  geocoded    Boolean  @default(false)
  geocodedAt  DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@map("customer_locations")
}

// Optimized route for a technician's day
model OptimizedRoute {
  id              String   @id @default(cuid())
  tenantId        String
  technicianId    String
  date            DateTime @db.Date
  totalDistance   Float?   // Total distance in km
  totalDuration   Int?     // Total duration in minutes
  stops           Json     // Array of stop objects with order
  optimizedAt     DateTime @default(now())
  appliedAt       DateTime?
  status          RouteStatus @default(PENDING)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([tenantId, technicianId, date])
  @@index([tenantId])
  @@index([technicianId])
  @@index([date])
  @@map("optimized_routes")
}

enum RouteStatus {
  PENDING     // Generated but not applied
  APPLIED     // Technician accepted route
  IN_PROGRESS // Route being executed
  COMPLETED   // All stops completed
  MODIFIED    // Manual changes made
}

// ============================================
// Phase 3: Customer Experience
// ============================================

// Customer authentication (separate from staff/Clerk auth)
model CustomerAuth {
  id               String   @id @default(cuid())
  customerId       String   @unique
  tenantId         String
  email            String?
  phone            String
  verificationCode String?
  codeExpiry       DateTime?
  magicLinkToken   String?  @unique
  magicLinkExpiry  DateTime?
  isVerified       Boolean  @default(false)
  lastLoginAt      DateTime?
  failedAttempts   Int      @default(0)
  lockedUntil      DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  sessions CustomerSession[]

  @@index([tenantId])
  @@index([customerId])
  @@index([phone])
  @@index([email])
  @@index([magicLinkToken])
  @@map("customer_auth")
}

// Customer portal sessions
model CustomerSession {
  id           String   @id @default(cuid())
  customerId   String
  customerAuthId String
  token        String   @unique
  userAgent    String?
  ipAddress    String?
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  customerAuth CustomerAuth @relation(fields: [customerAuthId], references: [id], onDelete: Cascade)

  @@index([customerId])
  @@index([token])
  @@map("customer_sessions")
}

// NPS Survey responses
model NpsSurvey {
  id            String   @id @default(cuid())
  tenantId      String
  jobId         String   @unique
  customerId    String
  score         Int?     // 1-10 NPS score
  feedback      String?  @db.Text
  sentAt        DateTime?
  respondedAt   DateTime?
  reviewClicked Boolean  @default(false)
  reviewPlatform String?  // "google", "yelp", etc.
  status        NpsSurveyStatus @default(PENDING)
  token         String   @unique
  createdAt     DateTime @default(now())

  job Job @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@index([status])
  @@index([token])
  @@map("nps_surveys")
}

enum NpsSurveyStatus {
  PENDING     // Not yet sent
  SENT        // Survey sent to customer
  RESPONDED   // Customer submitted score
  REVIEW_PROMPTED // Prompted for public review
  REVIEW_CLICKED  // Customer clicked review link
  EXPIRED     // Survey expired without response
}

// ============================================
// Phase 4: Advanced Features
// ============================================

// Sprint 4.1: Predictive Maintenance

// Customer equipment tracking
model CustomerEquipment {
  id              String              @id @default(cuid())
  tenantId        String
  customerId      String
  equipmentType   String              // e.g., "HVAC", "Water Heater", "Furnace"
  brand           String?
  model           String?
  serialNumber    String?
  installDate     DateTime?
  warrantyExpiry  DateTime?
  lastServiceDate DateTime?
  nextServiceDue  DateTime?
  condition       EquipmentCondition  @default(GOOD)
  notes           String?             @db.Text
  metadata        Json?               // Additional equipment-specific data
  isActive        Boolean             @default(true)
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  // Relations
  customer        Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  serviceHistory  EquipmentServiceHistory[]
  alerts          MaintenanceAlert[]

  @@index([tenantId])
  @@index([customerId])
  @@index([equipmentType])
  @@index([nextServiceDue])
  @@map("customer_equipment")
}

enum EquipmentCondition {
  EXCELLENT   // Like new
  GOOD        // Normal wear
  FAIR        // Needs attention soon
  POOR        // Requires immediate service
  CRITICAL    // Non-functional or unsafe
}

// Equipment service history
model EquipmentServiceHistory {
  id           String   @id @default(cuid())
  equipmentId  String
  tenantId     String
  jobId        String?  // Link to job if service was done through app
  serviceDate  DateTime
  serviceType  String   // e.g., "Routine Maintenance", "Repair", "Inspection"
  description  String?  @db.Text
  cost         Float?
  partsReplaced String?  @db.Text
  technicianId String?
  technicianName String?
  condition    EquipmentCondition?  // Condition after service
  notes        String?  @db.Text
  createdAt    DateTime @default(now())

  equipment CustomerEquipment @relation(fields: [equipmentId], references: [id], onDelete: Cascade)

  @@index([equipmentId])
  @@index([tenantId])
  @@index([serviceDate])
  @@map("equipment_service_history")
}

// Maintenance alerts and predictions
model MaintenanceAlert {
  id           String              @id @default(cuid())
  tenantId     String
  customerId   String
  equipmentId  String?             // Optional link to specific equipment
  alertType    MaintenanceAlertType
  priority     AlertPriority       @default(MEDIUM)
  title        String
  description  String              @db.Text
  reasoning    String?             @db.Text  // AI reasoning for the prediction
  confidence   Float?              // AI confidence score (0-1)
  dueDate      DateTime?           // When maintenance should be performed
  dismissedAt  DateTime?
  dismissReason String?
  convertedToCampaign String?      // Campaign ID if converted to outreach
  status       MaintenanceAlertStatus @default(PENDING)
  metadata     Json?               // Alert-specific data
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt

  equipment CustomerEquipment? @relation(fields: [equipmentId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([customerId])
  @@index([equipmentId])
  @@index([status])
  @@index([priority])
  @@index([dueDate])
  @@map("maintenance_alerts")
}

enum MaintenanceAlertType {
  AGE_BASED           // Equipment reaching end of typical lifespan
  USAGE_BASED         // Based on usage patterns
  SEASONAL            // Seasonal maintenance (e.g., HVAC before summer)
  WARRANTY_EXPIRING   // Warranty about to expire
  OVERDUE_SERVICE     // Missed scheduled service
  AI_PREDICTED        // AI-detected potential issue
  RECALL              // Product recall or safety issue
  EFFICIENCY          // Efficiency degradation detected
}

enum AlertPriority {
  LOW       // Informational, can wait
  MEDIUM    // Should be addressed within weeks
  HIGH      // Should be addressed soon
  URGENT    // Requires immediate attention
}

enum MaintenanceAlertStatus {
  PENDING     // Alert created, awaiting action
  NOTIFIED    // Customer has been notified
  SCHEDULED   // Maintenance appointment scheduled
  IN_PROGRESS // Work in progress
  COMPLETED   // Maintenance completed
  DISMISSED   // Alert dismissed (not needed)
  EXPIRED     // Alert expired without action
}

// Sprint 4.2: Dynamic Pricing

// Demand metrics for pricing calculations
model DemandMetrics {
  id           String   @id @default(cuid())
  tenantId     String
  date         DateTime @db.Date
  hour         Int?     // 0-23, null for daily aggregate
  dayOfWeek    Int?     // 0-6, Sunday to Saturday
  bookingCount Int      @default(0)
  completedJobs Int     @default(0)
  cancelledJobs Int     @default(0)
  capacityUsed Float    @default(0)  // Percentage of available slots used
  revenue      Float    @default(0)
  avgJobDuration Int?   // Average job duration in minutes
  peakHour     Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([tenantId, date, hour])
  @@index([tenantId])
  @@index([date])
  @@index([dayOfWeek])
  @@map("demand_metrics")
}

// Pricing rules for dynamic pricing
model PricingRule {
  id            String          @id @default(cuid())
  tenantId      String
  name          String
  description   String?
  ruleType      PricingRuleType
  conditions    Json            // Rule conditions (time, demand, urgency, etc.)
  multiplierMin Float           @default(1.0)  // Minimum multiplier
  multiplierMax Float           @default(1.5)  // Maximum multiplier
  flatAdjustment Float?         // Flat fee adjustment (optional)
  priority      Int             @default(0)    // Higher priority rules apply first
  isActive      Boolean         @default(true)
  startsAt      DateTime?       // Optional rule validity period
  endsAt        DateTime?
  appliedCount  Int             @default(0)    // How many times this rule was applied
  totalRevenue  Float           @default(0)    // Revenue attributed to this rule
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  @@index([tenantId])
  @@index([ruleType])
  @@index([isActive])
  @@index([priority])
  @@map("pricing_rules")
}

enum PricingRuleType {
  TIME_OF_DAY       // Different prices for morning/afternoon/evening
  DAY_OF_WEEK       // Weekend vs weekday pricing
  DEMAND_BASED      // Price increases with demand
  URGENCY           // Emergency/urgent service premium
  SEASONAL          // Holiday or seasonal pricing
  EARLY_BIRD        // Discount for booking in advance
  LOYALTY           // Customer loyalty discounts
  PROMOTIONAL       // Promotional pricing campaigns
}

// Service pricing configuration
model ServicePricing {
  id              String   @id @default(cuid())
  tenantId        String
  serviceId       String
  basePrice       Float
  minPrice        Float?   // Floor price
  maxPrice        Float?   // Ceiling price
  urgentMultiplier Float   @default(1.5)  // Standard urgency multiplier
  emergencyMultiplier Float @default(2.0) // Emergency multiplier
  dynamicPricingEnabled Boolean @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([tenantId, serviceId])
  @@index([tenantId])
  @@index([serviceId])
  @@map("service_pricing")
}

// Price quote history for auditing
model PriceQuoteHistory {
  id              String   @id @default(cuid())
  tenantId        String
  customerId      String?
  serviceId       String?
  basePrice       Float
  finalPrice      Float
  appliedRules    Json     // Array of rule IDs and their effects
  urgencyLevel    UrgencyLevel @default(STANDARD)
  demandFactor    Float    @default(1.0)
  requestedAt     DateTime
  scheduledFor    DateTime?
  converted       Boolean  @default(false)  // Whether this led to a booking
  createdAt       DateTime @default(now())

  @@index([tenantId])
  @@index([customerId])
  @@index([serviceId])
  @@index([requestedAt])
  @@map("price_quote_history")
}

enum UrgencyLevel {
  STANDARD      // Normal booking
  NEXT_DAY      // Next day service
  SAME_DAY      // Same day service
  URGENT        // Within hours
  EMERGENCY     // Immediate response
}

// Sprint 4.3: WhatsApp & Unified Messaging

// Customer messaging channels
model MessageChannel {
  id         String         @id @default(cuid())
  tenantId   String
  customerId String
  channel    ChannelType
  channelId  String         // Phone number for SMS/WhatsApp, email for email
  isActive   Boolean        @default(true)
  isVerified Boolean        @default(false)
  verifiedAt DateTime?
  preferences Json?         // Channel-specific preferences
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  @@unique([tenantId, customerId, channel])
  @@index([tenantId])
  @@index([customerId])
  @@index([channel])
  @@map("message_channels")
}

enum ChannelType {
  SMS
  WHATSAPP
  EMAIL
  IMESSAGE
}

// Conversation threads
model ConversationThread {
  id             String             @id @default(cuid())
  tenantId       String
  customerId     String
  customerName   String?
  customerPhone  String
  channel        ChannelType
  status         ConversationStatus @default(OPEN)
  priority       ConversationPriority @default(NORMAL)
  assignedTo     String?            // Staff user ID
  subject        String?
  lastMessageAt  DateTime?
  lastMessagePreview String?
  unreadCount    Int               @default(0)
  tags           String[]
  metadata       Json?
  closedAt       DateTime?
  closedBy       String?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  messages Message[]

  @@index([tenantId])
  @@index([customerId])
  @@index([status])
  @@index([assignedTo])
  @@index([lastMessageAt])
  @@map("conversation_threads")
}

enum ConversationStatus {
  OPEN          // Active conversation
  PENDING       // Awaiting response
  RESOLVED      // Completed/resolved
  CLOSED        // Closed without resolution
  SPAM          // Marked as spam
}

enum ConversationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// Individual messages
model Message {
  id           String           @id @default(cuid())
  threadId     String
  tenantId     String
  direction    MessageDirection
  content      String           @db.Text
  contentType  MessageContentType @default(TEXT)
  mediaUrl     String?
  mediaType    String?          // MIME type
  mediaSize    Int?             // Size in bytes
  status       MessageStatus    @default(PENDING)
  sentAt       DateTime?
  deliveredAt  DateTime?
  readAt       DateTime?
  failedAt     DateTime?
  failureReason String?
  externalId   String?          // Twilio message SID, WhatsApp ID, etc.
  senderName   String?
  senderPhone  String?
  metadata     Json?
  createdAt    DateTime         @default(now())

  thread ConversationThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@index([threadId])
  @@index([tenantId])
  @@index([direction])
  @@index([status])
  @@index([createdAt])
  @@map("messages")
}

enum MessageDirection {
  INBOUND    // From customer
  OUTBOUND   // To customer
}

enum MessageContentType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  LOCATION
  CONTACT
  TEMPLATE     // WhatsApp template message
}

enum MessageStatus {
  PENDING      // Not yet sent
  QUEUED       // In send queue
  SENT         // Sent to provider
  DELIVERED    // Delivered to recipient
  READ         // Read by recipient
  FAILED       // Failed to send
}

// WhatsApp message templates (required by WhatsApp Business API)
model WhatsAppTemplate {
  id            String               @id @default(cuid())
  tenantId      String
  name          String               // Template name (alphanumeric + underscore only)
  language      String               @default("en")
  category      WhatsAppTemplateCategory
  status        WhatsAppTemplateStatus @default(DRAFT)
  headerType    String?              // TEXT, IMAGE, VIDEO, DOCUMENT
  headerContent String?
  bodyText      String               @db.Text
  footerText    String?
  buttons       Json?                // Array of button configurations
  exampleValues Json?                // Sample values for template variables
  whatsappId    String?              // Template ID from WhatsApp
  submittedAt   DateTime?
  approvedAt    DateTime?
  rejectedAt    DateTime?
  rejectionReason String?
  usageCount    Int                  @default(0)
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt

  @@unique([tenantId, name, language])
  @@index([tenantId])
  @@index([category])
  @@index([status])
  @@map("whatsapp_templates")
}

enum WhatsAppTemplateCategory {
  MARKETING        // Promotional messages
  UTILITY          // Transactional messages (confirmations, reminders)
  AUTHENTICATION   // OTP and verification codes
}

enum WhatsAppTemplateStatus {
  DRAFT            // Not yet submitted
  PENDING          // Submitted, awaiting approval
  APPROVED         // Approved for use
  REJECTED         // Rejected by WhatsApp
  DISABLED         // Disabled by tenant
}

// Quick reply templates for agents
model QuickReply {
  id           String   @id @default(cuid())
  tenantId     String
  title        String   // Short title for display
  content      String   @db.Text
  category     String?  // Grouping category
  shortcut     String?  // Keyboard shortcut (e.g., "/greeting")
  channels     ChannelType[]  // Which channels this can be used on
  usageCount   Int      @default(0)
  createdBy    String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([tenantId])
  @@index([category])
  @@index([shortcut])
  @@map("quick_replies")
}
