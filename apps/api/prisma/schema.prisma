// Prisma Schema for Smart Business Assistant
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Multi-tenancy: Each business is a tenant
model Tenant {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  email     String   @unique
  phone     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  users        User[]
  customers    Customer[]
  services     Service[]
  appointments Appointment[]
  quotes       Quote[]
  invoices     Invoice[]
  availability TechnicianAvailability[]
  timeOff      TimeOff[]
  callLogs     CallLog[]
  invitations  TeamInvitation[]
  jobs         Job[]
  smsBroadcasts SmsBroadcast[]
  settings     TenantSettings?
  reviewRequests ReviewRequest[]

  @@map("tenants")
}

// Users belong to tenants (staff/admin)
model User {
  id        String     @id @default(cuid())
  email     String     @unique
  password  String?
  name      String
  phone     String?
  role      UserRole   @default(TECHNICIAN)
  status    UserStatus @default(ACTIVE)
  tenantId  String
  clerkId   String?    @unique
  invitedBy String?
  joinedAt  DateTime?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // Relations
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointments Appointment[]
  availability TechnicianAvailability[]
  timeOff      TimeOff[]
  jobs         Job[]
  locations    TechnicianLocation[]

  @@index([tenantId])
  @@index([clerkId])
  @@index([status])
  @@map("users")
}

enum UserRole {
  OWNER      // Business owner, full access
  ADMIN      // Admin access, can manage team
  DISPATCHER // Can manage appointments and customers
  TECHNICIAN // Field worker, limited access
}

enum UserStatus {
  PENDING    // Invited but not yet joined
  ACTIVE     // Active team member
  DEACTIVATED // Removed from team
}

// Team invitations
model TeamInvitation {
  id        String           @id @default(cuid())
  email     String
  name      String?
  role      UserRole         @default(TECHNICIAN)
  tenantId  String
  token     String           @unique
  status    InvitationStatus @default(PENDING)
  expiresAt DateTime
  invitedBy String
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, email])
  @@index([token])
  @@index([tenantId])
  @@map("team_invitations")
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

// Customers are tenant-specific
model Customer {
  id        String   @id @default(cuid())
  name      String
  email     String?
  phone     String
  address   String?
  notes     String?
  tenantId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointments Appointment[]
  quotes       Quote[]
  invoices     Invoice[]
  reviewRequests ReviewRequest[]
  context      CustomerContext?
  preferences  CustomerPreference?
  location     CustomerLocation?

  @@index([tenantId])
  @@index([phone])
  @@map("customers")
}

// Services catalog
model Service {
  id              String        @id @default(cuid())
  name            String
  description     String?
  durationMinutes Int           @default(60)
  price           Float?
  tenantId        String
  // Availability settings
  bufferMinutes   Int           @default(0)      // Buffer time after appointment
  maxPerDay       Int?                            // Max appointments per day (null = unlimited)
  leadTimeHours   Int           @default(24)     // Minimum hours before appointment can be booked
  isActive        Boolean       @default(true)   // Whether service accepts bookings
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointments Appointment[]
  availability ServiceAvailability[]

  @@index([tenantId])
  @@map("services")
}

// Service-specific availability windows
model ServiceAvailability {
  id         String   @id @default(cuid())
  serviceId  String
  dayOfWeek  Int      // 0 = Sunday, 6 = Saturday
  startTime  String   // Format: "HH:mm" (e.g., "09:00")
  endTime    String   // Format: "HH:mm" (e.g., "17:00")
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([serviceId, dayOfWeek])
  @@index([serviceId])
  @@map("service_availability")
}

// Appointments for services
model Appointment {
  id                String            @id @default(cuid())
  customerId        String
  serviceId         String?
  assignedTo        String?
  scheduledAt       DateTime
  duration          Int               @default(60)
  status            AppointmentStatus @default(SCHEDULED)
  notes             String?
  tenantId          String
  confirmationCode  String?           @unique
  manageToken       String?           @unique  // Token for customer to manage their booking
  cancelledAt       DateTime?
  cancelReason      String?
  googleCalendarEventId String?       // Google Calendar event ID for sync
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // Relations
  tenant       Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer     Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  service      Service? @relation(fields: [serviceId], references: [id], onDelete: SetNull)
  assignedUser User?    @relation(fields: [assignedTo], references: [id], onDelete: SetNull)
  job          Job?

  @@index([tenantId])
  @@index([customerId])
  @@index([scheduledAt])
  @@index([assignedTo])
  @@index([status])
  @@index([manageToken])
  @@map("appointments")
}

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// Quotes/Estimates
model Quote {
  id          String      @id @default(cuid())
  quoteNumber String      @unique
  description String
  amount      Float
  validUntil  DateTime
  status      QuoteStatus @default(DRAFT)
  customerId  String
  tenantId    String
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  items    QuoteItem[]

  @@index([tenantId])
  @@index([customerId])
  @@map("quotes")
}

enum QuoteStatus {
  DRAFT
  SENT
  ACCEPTED
  REJECTED
  EXPIRED
}

model QuoteItem {
  id          String   @id @default(cuid())
  description String
  quantity    Int
  unitPrice   Float
  total       Float
  quoteId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  quote Quote @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  @@index([quoteId])
  @@map("quote_items")
}

// Invoices
model Invoice {
  id            String        @id @default(cuid())
  invoiceNumber String        @unique
  description   String
  amount        Float
  paidAmount    Float         @default(0)
  status        InvoiceStatus @default(DRAFT)
  dueDate       DateTime
  paidAt        DateTime?
  sentAt        DateTime?
  customerId    String
  quoteId       String?
  tenantId      String
  stripePaymentIntentId String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Relations
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  items    InvoiceItem[]

  @@index([tenantId])
  @@index([customerId])
  @@index([quoteId])
  @@map("invoices")
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
  CANCELLED
}

model InvoiceItem {
  id          String   @id @default(cuid())
  description String
  quantity    Int
  unitPrice   Float
  total       Float
  invoiceId   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@map("invoice_items")
}

// Technician regular availability schedule
model TechnicianAvailability {
  id         String   @id @default(cuid())
  tenantId   String
  userId     String
  dayOfWeek  Int      // 0 = Sunday, 6 = Saturday
  startTime  String   // Format: "HH:mm" (e.g., "09:00")
  endTime    String   // Format: "HH:mm" (e.g., "17:00")
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([userId])
  @@index([dayOfWeek])
  @@unique([tenantId, userId, dayOfWeek])
  @@map("technician_availability")
}

// Time off / exceptions to regular schedule
model TimeOff {
  id        String   @id @default(cuid())
  tenantId  String
  userId    String
  startDate DateTime
  endDate   DateTime
  reason    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([userId])
  @@index([startDate, endDate])
  @@map("time_off")
}

// Voice AI call logs
model CallLog {
  id          String         @id @default(cuid())
  tenantId    String
  vapiCallId  String         @unique
  callerPhone String
  direction   CallDirection  @default(INBOUND)
  status      CallStatus     @default(QUEUED)
  duration    Int?           // Duration in seconds
  transcript  String?        @db.Text
  summary     String?
  metadata    Json?          // Store additional call data
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([vapiCallId])
  @@index([callerPhone])
  @@index([status])
  @@map("call_logs")
}

enum CallDirection {
  INBOUND
  OUTBOUND
}

enum CallStatus {
  QUEUED
  RINGING
  IN_PROGRESS
  FORWARDING
  ENDED
  FAILED
}

// Google Calendar Integration
model CalendarIntegration {
  id           String   @id @default(cuid())
  tenantId     String   @unique
  accessToken  String   @db.Text
  refreshToken String   @db.Text
  expiresAt    DateTime
  calendarId   String?  // Primary calendar ID to sync to
  syncEnabled  Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("calendar_integrations")
}

// Job tracking - extends appointments with work details
model Job {
  id            String    @id @default(cuid())
  tenantId      String
  appointmentId String    @unique
  technicianId  String?
  status        JobStatus @default(NOT_STARTED)
  startedAt     DateTime?
  completedAt   DateTime?
  notes         String?   @db.Text
  workSummary   String?   @db.Text  // Summary of work performed
  materialsUsed String?   @db.Text  // Materials/parts used
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  tenant      Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  technician  User?      @relation(fields: [technicianId], references: [id], onDelete: SetNull)
  photos      JobPhoto[]
  reviewRequest ReviewRequest?

  @@index([tenantId])
  @@index([appointmentId])
  @@index([technicianId])
  @@index([status])
  @@map("jobs")
}

enum JobStatus {
  NOT_STARTED
  EN_ROUTE
  IN_PROGRESS
  ON_HOLD
  COMPLETED
  CANCELLED
}

// Photos attached to jobs
model JobPhoto {
  id          String        @id @default(cuid())
  jobId       String
  url         String        // S3 or storage URL
  key         String        // Storage key for deletion
  filename    String
  mimeType    String
  size        Int           // File size in bytes
  type        JobPhotoType  @default(DURING)
  caption     String?
  uploadedBy  String?       // User ID who uploaded
  createdAt   DateTime      @default(now())

  // Relations
  job Job @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@map("job_photos")
}

enum JobPhotoType {
  BEFORE
  DURING
  AFTER
}

// SMS Broadcast messages
model SmsBroadcast {
  id          String              @id @default(cuid())
  tenantId    String
  message     String              @db.Text
  sentBy      String              // User ID who sent
  recipientCount Int
  successCount   Int              @default(0)
  failureCount   Int              @default(0)
  status      BroadcastStatus     @default(PENDING)
  targetRoles UserRole[]          // Which roles to send to (empty = all)
  createdAt   DateTime            @default(now())
  completedAt DateTime?

  // Relations
  tenant    Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  recipients SmsBroadcastRecipient[]

  @@index([tenantId])
  @@index([status])
  @@map("sms_broadcasts")
}

model SmsBroadcastRecipient {
  id          String   @id @default(cuid())
  broadcastId String
  userId      String
  phone       String
  status      String   @default("pending") // pending, sent, failed
  error       String?
  sentAt      DateTime?

  // Relations
  broadcast SmsBroadcast @relation(fields: [broadcastId], references: [id], onDelete: Cascade)

  @@index([broadcastId])
  @@map("sms_broadcast_recipients")
}

enum BroadcastStatus {
  PENDING
  SENDING
  COMPLETED
  FAILED
}

// Tenant Settings
model TenantSettings {
  id                String   @id @default(cuid())
  tenantId          String   @unique
  businessHours     Json?    // { monday: { start: "09:00", end: "17:00" }, ... }
  timezone          String   @default("America/New_York")
  appointmentReminders Boolean @default(true)
  reminderHoursBefore Int     @default(24)
  autoConfirmBookings Boolean @default(false)
  reviewRequestEnabled Boolean @default(true)
  reviewRequestDelay  Int     @default(24) // Hours after job completion
  googleReviewUrl     String?
  yelpReviewUrl       String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  @@map("tenant_settings")
}

// Review Requests
model ReviewRequest {
  id          String   @id @default(cuid())
  tenantId    String
  jobId       String   @unique
  customerId  String
  status      ReviewRequestStatus @default(PENDING)
  sentAt      DateTime?
  clickedAt   DateTime?
  platform    String?  // "google" or "yelp"
  createdAt   DateTime @default(now())

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  job      Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([status])
  @@map("review_requests")
}

enum ReviewRequestStatus {
  PENDING
  SENT
  CLICKED
  SKIPPED
}

// ============================================
// Phase 2: AI Core Features
// ============================================

// Customer context for AI personalization
model CustomerContext {
  id              String   @id @default(cuid())
  tenantId        String
  customerId      String   @unique
  lastServiceType String?
  preferredTime   String?  // e.g., "morning", "afternoon", "evening"
  totalVisits     Int      @default(0)
  totalSpent      Float    @default(0)
  aiSummary       String?  @db.Text  // AI-generated summary of customer history
  preferences     Json?    // Additional preferences (e.g., specific technician, communication style)
  lastInteraction DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@map("customer_contexts")
}

// Outbound campaign management
model OutboundCampaign {
  id           String               @id @default(cuid())
  tenantId     String
  name         String
  type         OutboundCampaignType
  status       OutboundCampaignStatus @default(DRAFT)
  scheduledFor DateTime?
  completedAt  DateTime?
  targetCount  Int                  @default(0)
  successCount Int                  @default(0)
  failureCount Int                  @default(0)
  template     String?              @db.Text  // Message/call script template
  metadata     Json?                // Campaign-specific settings
  createdBy    String?
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  // Relations
  calls OutboundCall[]

  @@index([tenantId])
  @@index([status])
  @@index([scheduledFor])
  @@map("outbound_campaigns")
}

enum OutboundCampaignType {
  APPOINTMENT_REMINDER  // Remind about upcoming appointments
  FOLLOW_UP_SURVEY      // Post-job satisfaction survey
  PAYMENT_REMINDER      // Payment due reminders
  MAINTENANCE_REMINDER  // Scheduled maintenance reminders
  PROMOTIONAL           // Promotional campaigns
}

enum OutboundCampaignStatus {
  DRAFT
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  PAUSED
}

// Individual outbound calls within a campaign
model OutboundCall {
  id           String             @id @default(cuid())
  campaignId   String
  customerId   String
  customerPhone String
  status       OutboundCallStatus @default(PENDING)
  scheduledFor DateTime?
  attemptCount Int                @default(0)
  lastAttemptAt DateTime?
  completedAt  DateTime?
  vapiCallId   String?            // Link to Vapi call if initiated
  outcome      String?            // Call outcome (answered, voicemail, no_answer, etc.)
  notes        String?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  // Relations
  campaign OutboundCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@index([campaignId])
  @@index([customerId])
  @@index([status])
  @@index([scheduledFor])
  @@map("outbound_calls")
}

enum OutboundCallStatus {
  PENDING
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  FAILED
  SKIPPED
}

// Photo-based quote requests with AI analysis
model PhotoQuoteRequest {
  id                String              @id @default(cuid())
  tenantId          String
  customerId        String?
  customerPhone     String?
  customerEmail     String?
  photoUrl          String              // S3/storage URL of uploaded photo
  photoKey          String?             // Storage key for deletion
  aiAnalysis        Json?               // Full AI analysis response
  issueDescription  String?             // AI-identified issue description
  suggestedService  String?             // Recommended service type
  estimatedPriceMin Float?              // Lower bound estimate
  estimatedPriceMax Float?              // Upper bound estimate
  confidence        Float?              // AI confidence score (0-1)
  complexity        PhotoComplexity     @default(MEDIUM)
  status            PhotoQuoteStatus    @default(PENDING)
  customerNotes     String?             // Customer's description of the issue
  staffNotes        String?             // Staff follow-up notes
  convertedToQuote  String?             // Quote ID if converted
  expiresAt         DateTime
  viewedAt          DateTime?
  respondedAt       DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@index([tenantId])
  @@index([customerId])
  @@index([status])
  @@index([createdAt])
  @@map("photo_quote_requests")
}

enum PhotoQuoteStatus {
  PENDING       // Uploaded, waiting for AI analysis
  ANALYZING     // AI analysis in progress
  READY         // Analysis complete, awaiting customer response
  ACCEPTED      // Customer accepted the estimate
  REJECTED      // Customer declined
  CONVERTED     // Converted to formal quote
  EXPIRED       // Request expired
}

enum PhotoComplexity {
  SIMPLE        // Minor repair, quick fix
  MEDIUM        // Standard job
  COMPLEX       // Major repair, multiple issues
  REQUIRES_INSPECTION // Cannot estimate from photo alone
}

// ============================================
// Sprint 2.3: Smart Scheduling
// ============================================

// Customer scheduling preferences (learned from behavior)
model CustomerPreference {
  id                 String   @id @default(cuid())
  customerId         String   @unique
  tenantId           String
  preferredDays      Int[]    // 0=Sunday, 6=Saturday
  preferredTimeStart String?  // e.g., "09:00"
  preferredTimeEnd   String?  // e.g., "12:00"
  preferredTechnician String? // Preferred technician ID
  avoidDays          Int[]    // Days to avoid
  learningConfidence Float    @default(0)  // 0-1, increases with more data points
  dataPoints         Int      @default(0)  // Number of appointments used for learning
  lastUpdated        DateTime @default(now())
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@map("customer_preferences")
}

// Real-time technician location tracking
model TechnicianLocation {
  id         String   @id @default(cuid())
  userId     String
  tenantId   String
  latitude   Float
  longitude  Float
  accuracy   Float?   // GPS accuracy in meters
  heading    Float?   // Direction in degrees
  speed      Float?   // Speed in m/s
  status     TechnicianLocationStatus @default(IDLE)
  recordedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([userId])
  @@index([recordedAt])
  @@map("technician_locations")
}

enum TechnicianLocationStatus {
  IDLE        // Not on a job
  EN_ROUTE    // Traveling to customer
  ON_SITE     // At customer location
  BREAK       // On break
  OFFLINE     // Not tracking
}

// Customer address with geocoded coordinates
model CustomerLocation {
  id          String   @id @default(cuid())
  customerId  String   @unique
  tenantId    String
  address     String
  city        String?
  state       String?
  zipCode     String?
  country     String   @default("US")
  latitude    Float?
  longitude   Float?
  geocoded    Boolean  @default(false)
  geocodedAt  DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([customerId])
  @@map("customer_locations")
}

// Optimized route for a technician's day
model OptimizedRoute {
  id              String   @id @default(cuid())
  tenantId        String
  technicianId    String
  date            DateTime @db.Date
  totalDistance   Float?   // Total distance in km
  totalDuration   Int?     // Total duration in minutes
  stops           Json     // Array of stop objects with order
  optimizedAt     DateTime @default(now())
  appliedAt       DateTime?
  status          RouteStatus @default(PENDING)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([tenantId, technicianId, date])
  @@index([tenantId])
  @@index([technicianId])
  @@index([date])
  @@map("optimized_routes")
}

enum RouteStatus {
  PENDING     // Generated but not applied
  APPLIED     // Technician accepted route
  IN_PROGRESS // Route being executed
  COMPLETED   // All stops completed
  MODIFIED    // Manual changes made
}
